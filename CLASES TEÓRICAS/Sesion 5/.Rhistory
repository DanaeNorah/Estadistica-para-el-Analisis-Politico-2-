aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT, data=free,FUN=plyr::each(Moda = mode))
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each( Moda = mode))
# convertir en data frame, y
tablafree=t(as.data.frame(ag))
tablafree
library(knitr)
library(kableExtra)
kable(tablafree, format = "html", digits = 2)%>%kable_styling()
View(free)
FUN=plyr
FUN=plyr::each
plyr::each
library(plyr) # para funcion "each"..
# nota el uso de as.matrix con cbind:
aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT, data=free,FUN=plyr::each(Moda = mode))
View(pam.result)
View(tablafree)
pam.result=pam(dist, 4,cluster.only = F)
free$clusterPT=pam.result$cluster
library(plyr) # para funcion "each"..
# nota el uso de as.matrix con cbind:
aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT, data=free,FUN=plyr::each(Moda = mode))
pam.result=pam(dist, 3,cluster.only = F)
free$clusterPT=pam.result$cluster
# coleccion
library(htmltab)
demolink = "https://en.wikipedia.org/wiki/Democracy_Index"
demopath = '//*[@id="mw-content-text"]/div/table[2]/tbody'
demo<- htmltab(doc = demolink, which =demopath)
# coleccion
library(htmltab)
demolink = "https://en.wikipedia.org/wiki/Democracy_Index"
demopath = '//*[@id="mw-content-text"]/div/table[2]/tbody'
demo<- htmltab(doc = demolink, which =demopath)
# coleccion
library(htmltab)
demolink = "https://en.wikipedia.org/wiki/Democracy_Index"
demopath = '//*[@id="mw-content-text"]/div/table[2]/tbody'
demo<- htmltab(doc = demolink, which =demopath)
# coleccion
library(htmltab)
demolink = "https://en.wikipedia.org/wiki/Democracy_Index"
demopath = '//*[@id="mw-content-text"]/div/table[2]/tbody'
demo<- htmltab(doc = demolink, which =demopath)
# coleccion
library(htmltab)
demolink = "https://en.wikipedia.org/wiki/Democracy_Index"
demopath = '//*[@id="mw-content-text"]/div/table[2]/tbody'
demo<- htmltab(doc = demolink, which =demopath)
# coleccion
library(htmltab)
demolink = "https://en.wikipedia.org/wiki/Democracy_Index"
demopath = '//*[@id="mw-content-text"]/div/table[2]/tbody'
demo<- htmltab(doc = demolink, which =demopath)
# coleccion
library(htmltab)
demolink = "https://en.wikipedia.org/wiki/Democracy_Index"
demopath = '//*[@id="mw-content-text"]/div/table[2]/tbody'
demo<- htmltab(doc = demolink, which =demopath)
# coleccion
library(htmltab)
demolink = "https://en.wikipedia.org/wiki/Democracy_Index"
demopath = '//*[@id="mw-content-text"]/div/table[2]/tbody'
demo<- htmltab(doc = demolink, which =demopath)
aggregate
# coleccion
library(htmltab)
demolink = "https://en.wikipedia.org/wiki/Democracy_Index"
demopath = '//*[@id="mw-content-text"]/div/table[2]/tbody'
demo<- htmltab(doc = demolink, which =demopath)
# coleccion
library(htmltab)
demolink = "https://en.wikipedia.org/wiki/Democracy_Index"
demopath = '//*[@id="mw-content-text"]/div/table[2]/tbody'
demo <- htmltab(doc = demolink, which =demopath)
# coleccion
library(htmltab)
demolink = "https://en.wikipedia.org/wiki/Democracy_Index"
demopath = '//*[@id="mw-content-text"]/div/table[2]/tbody'
demo <- htmltab(doc = demolink, which =demopath)
# coleccion
library(htmltab)
demolink = "https://en.wikipedia.org/wiki/Democracy_Index"
demopath = '//*[@id="mw-content-text"]/div/table[2]/tbody'
demo <- htmltab(doc = demolink, which =demopath)
# coleccion
library(htmltab)
demolink = "https://en.wikipedia.org/wiki/Democracy_Index"
demopath = '//*[@id="mw-content-text"]/div/table[2]/tbody'
demo <- htmltab(doc = demolink, which =demopath)
lfree="https://github.com/MAGALLANESJoseManuel/projectoTest/raw/master/free.csv"
free=read.csv(lfree,stringsAsFactors = F)
row.names(free)=free$Country
# alternativa a complete.cases:
free=na.omit(free)
free[,c(2:4)]=lapply(free[,c(2:4)],as.factor)
str(free)
library(cluster)
# usar en C() las dimensiones de interes:
dist= daisy(free[,c(2:4)], metric="gower")
pam.result=pam(dist, 3,cluster.only = F)
free$clusterPT=pam.result$cluster
library(plyr) # para funcion "each"..
# nota el uso de as.matrix con cbind:
aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT, data=free,FUN=plyr::each(Moda = mode))
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each( Moda = mode))
# convertir en data frame, y
tablafree=t(as.data.frame(ag))
tablafree
library(knitr)
library(kableExtra)
kable(tablafree, format = "html", digits = 2)%>%kable_styling()
setwd("C:/Users/Equipo/Desktop/CURSOS PUCP/6 SEXTO CICLO/Estadística para el Análisis Político 2/Estadistica-para-el-Analisis-Politico-2-/CLASES TEÓRICAS/Sesion 5")
# coleccion
library(htmltab)
demolink = "https://en.wikipedia.org/wiki/Democracy_Index"
demopath = '//*[@id="mw-content-text"]/div/table[2]/tbody'
demo <- htmltab(doc = demolink, which =demopath)
library(htmltab)
demolink = "https://en.wikipedia.org/wiki/Democracy_Index"
demopath = '//*[@id="mw-content-text"]/div/table[2]/tbody'
demo <- htmltab(doc = demolink, which =demopath)
library(plyr) # para funcion "each"..
# nota el uso de as.matrix con cbind:
aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT, data=free,FUN=plyr::each(mediana = median))
library(knitr)
library(kableExtra)
kable(tablafree, format = "html", digits = 2)%>%kable_styling()
lfree="https://github.com/MAGALLANESJoseManuel/projectoTest/raw/master/free.csv"
free=read.csv(lfree,stringsAsFactors = F)
row.names(free)=free$Country
# alternativa a complete.cases:
free=na.omit(free)
free[,c(2:4)]=lapply(free[,c(2:4)],as.factor)
str(free)
library(cluster)
# usar en C() las dimensiones de interes:
dist= daisy(free[,c(2:4)], metric="gower")
pam.result=pam(dist, 3,cluster.only = F)
free$clusterPT=pam.result$cluster
library(plyr) # para funcion "each"..
# nota el uso de as.matrix con cbind:
aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT, data=free,FUN=plyr::each(mediana = median))
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each( Moda = mode))
# convertir en data frame, y
tablafree=t(as.data.frame(ag))
tablafree
library(knitr)
library(kableExtra)
kable(tablafree, format = "html", digits = 2)%>%kable_styling()
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each( mediana = median))
# convertir en data frame, y
tablafree=t(as.data.frame(ag))
tablafree
lfree="https://github.com/MAGALLANESJoseManuel/projectoTest/raw/master/free.csv"
free=read.csv(lfree,stringsAsFactors = F)
row.names(free)=free$Country
# alternativa a complete.cases:
free=na.omit(free)
free[,c(2:4)]=lapply(free[,c(2:4)],as.factor)
str(free)
library(cluster)
# usar en C() las dimensiones de interes:
dist= daisy(free[,c(2:4)], metric="gower")
pam.result=pam(dist, 3,cluster.only = F)
free$clusterPT=pam.result$cluster
library(plyr) # para funcion "each"..
# nota el uso de as.matrix con cbind:
aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT, data=free,FUN=plyr::each(mediana = median))
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each( mediana = median))
# convertir en data frame, y
tablafree=t(as.data.frame(ag))
tablafree
library(knitr)
library(kableExtra)
kable(tablafree, format = "html", digits = 2)%>%kable_styling()
lfree="https://github.com/MAGALLANESJoseManuel/projectoTest/raw/master/free.csv"
free=read.csv(lfree,stringsAsFactors = F)
row.names(free)=free$Country
# alternativa a complete.cases:
free=na.omit(free)
free[,c(2:4)]=lapply(free[,c(2:4)],as.factor)
str(free)
library(cluster)
# usar en C() las dimensiones de interes:
dist= daisy(free[,c(2:4)], metric="gower")
pam.result=pam(dist, 3,cluster.only = F)
free$clusterPT=pam.result$cluster
library(plyr) # para funcion "each"..
# nota el uso de as.matrix con cbind:
aggregate(as.matrix(cbind(free[,c(2:5)]))~ clusterPT, data=free,FUN=plyr::each(mediana = median))
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:5)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each( mediana = median))
# convertir en data frame, y
tablafree=t(as.data.frame(ag))
tablafree
library(knitr)
library(kableExtra)
kable(tablafree, format = "html", digits = 2)%>%kable_styling()
free[,c(1:4)]=lapply(free[,c(1:4)],as.factor)
str(free)
lfree="https://github.com/MAGALLANESJoseManuel/projectoTest/raw/master/free.csv"
free=read.csv(lfree,stringsAsFactors = F)
row.names(free)=free$Country
# alternativa a complete.cases:
free=na.omit(free)
free[,c(1:4)]=lapply(free[,c(1:4)],as.factor)
str(free)
library(cluster)
# usar en C() las dimensiones de interes:
dist= daisy(free[,c(2:4)], metric="gower")
pam.result=pam(dist, 3,cluster.only = F)
free$clusterPT=pam.result$cluster
library(plyr) # para funcion "each"..
# nota el uso de as.matrix con cbind:
aggregate(as.matrix(cbind(free[,c(2:5)]))~ clusterPT, data=free,FUN=plyr::each(mediana = median))
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:5)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each( mediana = median))
# convertir en data frame, y
tablafree=t(as.data.frame(ag))
tablafree
library(knitr)
library(kableExtra)
kable(tablafree, format = "html", digits = 2)%>%kable_styling()
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:5)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each(median))
# convertir en data frame, y
tablafree=t(as.data.frame(ag))
tablafree
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:5)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each(Median))
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:5)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each(MD = median()))
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:5)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each(MD = median)
# convertir en data frame, y
tablafree=t(as.data.frame(ag))
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:5)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each(MD = median()))
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:5)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each(MD = median))
# convertir en data frame, y
tablafree=t(as.data.frame(ag))
tablafree
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(,2:5)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each(MD = median))
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:5)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each(MD = median))
# convertir en data frame, y
tablafree=t(as.data.frame(ag))
tablafree
lfree="https://github.com/MAGALLANESJoseManuel/projectoTest/raw/master/free.csv"
free=read.csv(lfree,stringsAsFactors = F)
row.names(free)=free$Country
# alternativa a complete.cases:
free=na.omit(free)
free[,c(1:4)]=lapply(free[,c(1:4)],as.factor)
str(free)
library(cluster)
# usar en C() las dimensiones de interes:
dist= daisy(free[,c(2:4)], metric="gower")
pam.result=pam(dist, 3,cluster.only = F)
free$clusterPT=pam.result$cluster
library(plyr) # para funcion "each"..
# nota el uso de as.matrix con cbind:
aggregate(as.matrix(cbind(free[,c(2:5)]))~ clusterPT, data=free,FUN=plyr::each(mediana = median))
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:5)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each(MD = median))
# convertir en data frame, y
tablafree=t(as.data.frame(ag))
tablafree
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:5)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each(MD = median))
# convertir en data frame, y
tablafree=t(as.data.frame(ag))
tablafree
library(knitr)
library(kableExtra)
kable(tablafree, format = "html", digits = 2)%>%kable_styling()
library(plyr) # para funcion "each"..
# nota el uso de as.matrix con cbind:
aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT, data=free,FUN=plyr::each(mediana = median))
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:5)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each(MD = median))
# convertir en data frame, y
tablafree=t(as.data.frame(ag))
tablafree
lfree="https://github.com/MAGALLANESJoseManuel/projectoTest/raw/master/free.csv"
free=read.csv(lfree,stringsAsFactors = F)
row.names(free)=free$Country
# alternativa a complete.cases:
free=na.omit(free)
free[,c(1:4)]=lapply(free[,c(1:4)],as.factor)
str(free)
library(cluster)
# usar en C() las dimensiones de interes:
dist= daisy(free[,c(2:4)], metric="gower")
pam.result=pam(dist, 3,cluster.only = F)
free$clusterPT=pam.result$cluster
library(plyr) # para funcion "each"..
# nota el uso de as.matrix con cbind:
aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT, data=free,FUN=plyr::each(mediana = median))
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each(MD = median))
# convertir en data frame, y
tablafree=t(as.data.frame(ag))
tablafree
library(knitr)
library(kableExtra)
kable(tablafree, format = "html", digits = 2)%>%kable_styling()
free=as.factor(free)
str(free)
lfree="https://github.com/MAGALLANESJoseManuel/projectoTest/raw/master/free.csv"
free=read.csv(lfree,stringsAsFactors = F)
row.names(free)=free$Country
# alternativa a complete.cases:
free=na.omit(free)
free=as.factor(free)
str(free)
library(cluster)
# usar en C() las dimensiones de interes:
dist= daisy(free[,c(2:4)], metric="gower")
lfree="https://github.com/MAGALLANESJoseManuel/projectoTest/raw/master/free.csv"
free=read.csv(lfree,stringsAsFactors = F)
row.names(free)=free$Country
# alternativa a complete.cases:
free=na.omit(free)
free=as.factor(free)
str(free)
free[,c(2:4)]=lapply(free[,c(2:4)],as.factor)
lfree="https://github.com/MAGALLANESJoseManuel/projectoTest/raw/master/free.csv"
free=read.csv(lfree,stringsAsFactors = F)
row.names(free)=free$Country
# alternativa a complete.cases:
free=na.omit(free)
free[,c(2:4)]=lapply(free[,c(2:4)],as.factor)
str(free)
library(cluster)
# usar en C() las dimensiones de interes:
dist= daisy(free[,c(2:4)], metric="gower")
library(cluster)
# usar en C() las dimensiones de interes:
dist= daisy(free[,c(2:4)], metric="gower")
pam.result=pam(dist, 3,cluster.only = F)
free$clusterPT=pam.result$cluster
lfree="https://github.com/MAGALLANESJoseManuel/projectoTest/raw/master/free.csv"
free=read.csv(lfree,stringsAsFactors = F)
row.names(free)=free$Country
# alternativa a complete.cases:
free=na.omit(free)
free[,c(2:4)]=lapply(free[,c(2:4)],as.factor)
str(free)
library(cluster)
# usar en C() las dimensiones de interes:
dist= daisy(free[,c(2:4)], metric="gower")
pam.result=pam(dist, 3,cluster.only = F)
free$clusterPT=pam.result$cluster
library(plyr) # para funcion "each"..
# nota el uso de as.matrix con cbind:
aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT, data=free,FUN=plyr::each(mediana = median))
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each(MD = median))
# convertir en data frame, y
tablafree=t(as.data.frame(ag))
tablafree
library(knitr)
library(kableExtra)
kable(tablafree, format = "html", digits = 2)%>%kable_styling()
lfree="https://github.com/MAGALLANESJoseManuel/projectoTest/raw/master/free.csv"
free=read.csv(lfree,stringsAsFactors = F)
# alternativa a complete.cases:
free=na.omit(free)
free[,c(2:4)]=lapply(free[,c(2:4)],as.factor)
str(free)
library(cluster)
# usar en C() las dimensiones de interes:
dist= daisy(free[,c(2:4)], metric="gower")
pam.result=pam(dist, 3,cluster.only = F)
free$clusterPT=pam.result$cluster
library(plyr) # para funcion "each"..
# nota el uso de as.matrix con cbind:
aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT, data=free,FUN=plyr::each(mediana = median))
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each(MD = median))
# convertir en data frame, y
tablafree=t(as.data.frame(ag))
tablafree
library(knitr)
library(kableExtra)
kable(tablafree, format = "html", digits = 2)%>%kable_styling()
lfree="https://github.com/MAGALLANESJoseManuel/projectoTest/raw/master/free.csv"
free=read.csv(lfree,stringsAsFactors = F)
row.names(free)=free$Country
# alternativa a complete.cases:
free=na.omit(free)
free[,c(2:4)]=lapply(free[,c(2:4)],as.factor)
str(free)
library(cluster)
# usar en C() las dimensiones de interes:
dist= daisy(free[,c(2:4)], metric="gower")
pam.result=pam(dist, 3,cluster.only = F)
free$clusterPT=pam.result$cluster
library(plyr) # para funcion "each"..
# nota el uso de as.matrix con cbind:
aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT, data=free,FUN=plyr::each(mediana = median))
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each(MD = median))
# convertir en data frame, y
tablafree=t(as.data.frame(ag))
tablafree
library(knitr)
library(kableExtra)
kable(tablafree, format = "html", digits = 2)%>%kable_styling()
lfree="https://github.com/MAGALLANESJoseManuel/projectoTest/raw/master/free.csv"
free=read.csv(lfree,stringsAsFactors = F)
row.names(free)=free$Country
# alternativa a complete.cases:
free=na.omit(free)
free[,c(2:4)]=lapply(free[,c(2:4)],as.factor)
str(free)
library(cluster)
# usar en C() las dimensiones de interes:
dist= daisy(free[,c(2:4)], metric="gower")
pam.result=pam(dist, 4,cluster.only = F)
free$clusterPT=pam.result$cluster
library(plyr) # para funcion "each"..
# nota el uso de as.matrix con cbind:
aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT, data=free,FUN=plyr::each(mediana = median))
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each(MD = median))
# convertir en data frame, y
tablafree=t(as.data.frame(ag))
tablafree
library(knitr)
library(kableExtra)
kable(tablafree, format = "html", digits = 2)%>%kable_styling()
lfree="https://github.com/MAGALLANESJoseManuel/projectoTest/raw/master/free.csv"
free=read.csv(lfree,stringsAsFactors = F)
row.names(free)=free$Country
# alternativa a complete.cases:
free=na.omit(free)
free[,c(2:4)]=lapply(free[,c(2:4)],as.factor)
str(free)
library(cluster)
# usar en C() las dimensiones de interes:
dist= daisy(free[,c(2:4)], metric="gower")
pam.result=pam(dist, 3,cluster.only = F)
free$clusterPT=pam.result$cluster
library(plyr) # para funcion "each"..
# nota el uso de as.matrix con cbind:
aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT, data=free,FUN=plyr::each(mediana = median))
# guardando resultado anterior en objeto "agg":
ag=aggregate(as.matrix(cbind(free[,c(2:4)]))~ clusterPT,
data=free, # luego las funciones que deseas
FUN=plyr::each(MD = median))
# convertir en data frame, y
tablafree=t(as.data.frame(ag))
tablafree
library(knitr)
library(kableExtra)
kable(tablafree, format = "html", digits = 2)%>%kable_styling()
